# Architecture Technical Report: Re:Search

## 1. Executive Summary

This report outlines the technical architecture for **Re:Search**, a "Knowledge Base Augmented" application. The proposed stack prioritizes **local-first performance**, **data ownership**, and **seamless AI integration**.

The core philosophy is to build a "Second Brain" that lives on the user's device, not in the cloud, while leveraging modern AI for research and synthesis.

## 2. Recommended Tech Stack

### A. Core Application (The Shell)
**Recommendation:** **Tauri 2.0** (Rust + Web Frontend)
- **Why:**
  - **Performance:** Significantly lower memory footprint than Electron (vital for a "always-open" knowledge app).
  - **Security:** Rust provides memory safety and fine-grained permissions.
  - **Backend Power:** The heavy lifting (web scraping, vector search, file I/O) is done in Rust, which is incredibly fast.
  - **Bundle Size:** <10MB vs ~100MB+ for Electron.
- **Alternative:** **Electron** (if pure JavaScript/TypeScript ecosystem is strictly required, but at cost of RAM).

### B. Frontend Framework
**Recommendation:** **React** + **Vite** + **Tailwind CSS**
- **Why:** Robust ecosystem, component reusability, and seamless integration with the recommended libraries below.

### C. The "Crazy Board" (Macro View)
**Recommendation:** **React Flow**
- **Why:**
  - **Node-Based:** Perfect for representing "Documents" or "Entities" as nodes with input/output handles (connections).
  - **Customizable:** We can create custom nodes (e.g., "Web Source Node", "Note Node", "Image Node").
  - **Scalability:** Handles thousands of nodes better than canvas-drawing libraries.
- **Alternative:** **Tldraw** (if freehand drawing/whiteboarding is prioritized over structured connections).

### D. The "Artifact" Editor (Micro View)
**Recommendation:** **Tiptap (based on ProseMirror)**
- **Why:**
  - **Headless:** Complete control over the UI (unlike Monaco which forces a "code editor" look).
  - **Markdown First:** Excellent serialization to/from Markdown.
  - **Extensions:** Massive ecosystem, including AI autocompletion, slash commands, and block-based editing (Notion-style).
- **Alternative:** **Milkdown** (another strong Markdown-first editor).

### E. The Brain (Data & AI)
**Recommendation:** **SQLite + sqlite-vec**
- **Why:**
  - **Single File:** The entire database (metadata, full text, and vectors) lives in one `.db` file. Easy to backup/sync.
  - **Performance:** `sqlite-vec` is a blazing fast vector search extension for SQLite.
  - **Simplicity:** No need to run a separate vector DB service (like Weaviate/Qdrant) alongside the app.
- **Alternative:** **LanceDB** (Embedded, highly performant for massive datasets, but adds another file format).

### F. AI Orchestration
**Recommendation:** **LangGraph** (Python via sidecar OR Rust native)
- **Why:**
  - **Stateful Agents:** Essential for the "Researcher Agent" which needs to plan, loop, and retain context over long tasks.
  - **Control:** Allows defining explicit "flows" (cycles) rather than just linear chains (LangChain).
- **Implementation Note:** We can run a small local Python sidecar (managed by Tauri) or use Rust bindings for LLM inference if using local models (e.g., `llm-chain` crate).

---

## 3. System Architecture Diagram

```mermaid
graph TD
    subgraph "Frontend (Webview)"
        UI[React UI]
        Canvas[React Flow Canvas]
        Editor[Tiptap Editor]
        Store[Zustand State]
    end

    subgraph "Tauri Core (Rust)"
        Bridge[Tauri Command Bridge]
        FS[File System Manager]
        Scraper[Web Scraper (reqwest/scraper)]
        VectorEngine[SQLite + sqlite-vec]
    end

    subgraph "AI Layer"
        Planner[LangGraph Agent]
        LLM[LLM Provider (OpenAI/Ollama)]
    end

    UI -->|Events| Bridge
    Canvas -->|Update Layout| Bridge
    Editor -->|Save Content| Bridge
    
    Bridge -->|Read/Write| FS
    Bridge -->|Query| VectorEngine
    
    Planner -->|Search| Scraper
    Planner -->|Index| VectorEngine
    Planner -->|Generate| LLM
```

## 4. Data Model Strategy

### The "Universal Node" Concept
Everything in the system is a **Node** in the SQLite database.

| Field | Type | Description |
| :--- | :--- | :--- |
| `id` | UUID | Unique Identifier |
| `type` | Enum | `artifact`, `source`, `concept`, `chat` |
| `content` | Text/Blob | The markdown content, URL, or chat history |
| `embedding` | Vector | The semantic representation (generated by local model or API) |
| `metadata` | JSON | Tags, creation date, source URL, author |

### Relationships (Edges)
Links between nodes are stored in an `edges` table, allowing for graph queries (e.g., "Show me all sources linked to 'Napoleon'").

## 5. Implementation Roadmap

### Phase 1: The Foundation (MVP)
- Set up Tauri + React + SQLite.
- Implement basic Markdown creation/editing (Tiptap).
- Implement file storage (saving `.md` files to disk).

### Phase 2: The Visualizer
- Integrate React Flow.
- Visualize saved files as nodes on the canvas.
- Allow creating links between nodes (persisted to DB).

### Phase 3: The Researcher
- Integrate `sqlite-vec` for semantic search.
- Build the "Ingestion Pipeline": Paste a URL -> Scrape -> Chunk -> Embed -> Store.
- Implement "Chat with Knowledge Base" (RAG).

### Phase 4: The Agent
- Implement the "Researcher Agent" (LangGraph).
- Give it tools: `search_web`, `read_page`, `save_note`.
- Build the UI for "Agent Missions" (e.g., progress bars, current thought process).

## 6. Key Challenges & Mitigations

1.  **LLM Cost/Privacy:**
    *   *Challenge:* Using GPT-4 for everything is expensive.
    *   *Mitigation:* Support **Ollama** (local models like Llama 3 or Mistral) out of the box for free, private intelligence. Use cloud LLMs only for complex reasoning tasks.

2.  **Scraping Reliability:**
    *   *Challenge:* The web is messy; extensive scraping can be blocked.
    *   *Mitigation:* Use a "Readability" parser (like Mozilla's readability.js ported to Rust) to extract clean text. Implement polite rate limiting.

3.  **Sync:**
    *   *Challenge:* How to access data across devices?
    *   *Mitigation:* Since the DB is a single SQLite file (and markdown files are plain text), the folder can simply be placed in Dropbox/Google Drive/iCloud. No complex sync server needed for v1.
